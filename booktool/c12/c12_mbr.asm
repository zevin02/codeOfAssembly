         ;代码清单12-1
         ;文件名：c12_mbr.asm
         ;文件说明：硬盘主引导扇区代码 
         ;创建日期：2011-10-27 22:52

         ;设置堆栈段和栈指针 
         mov eax,cs      
         mov ss,eax
         mov sp,0x7c00

         ;因为我们现在是32位处理器，所以即使是在实模式下，也可以使用32位第寄存器
         ;计算GDT所在的逻辑段地址,安装gdt
         mov eax,[cs:pgdt+0x7c00+0x02]      ;GDT的32位线性基地址 
         xor edx,edx 
         mov ebx,16  
         div ebx                            ;分解成16位逻辑地址 
       ;初始化ds，使其指向GDT所在低逻辑段
         mov ds,eax                         ;令DS指向该段以进行操作,eax是商，仅低16位有效
         mov ebx,edx                        ;段内起始偏移地址 ,edx中记录偏移地址,只有低16位有效

         ;创建0#描述符，它是空描述符，这是处理器的要求
         ;因为在任何时候，一个忘记初始化低指针，默认值就是0，所以访问这个地方就会被处理器给禁止
         mov dword [ebx+0x00],0x00000000
         mov dword [ebx+0x04],0x00000000  

         ;创建1#描述符，这是一个数据段，对应0~4GB的线性地址空间
         mov dword [ebx+0x08],0x0000ffff    ;基地址为0，段界限为0xfffff，也就是4G的空间大小
         mov dword [ebx+0x0c],0x00cf9200    ;粒度为4KB，存储器段描述符 

         ;创建保护模式下初始代码段描述符
         mov dword [ebx+0x10],0x7c0001ff    ;基地址为0x00007c00，512字节 
         mov dword [ebx+0x14],0x00409800    ;粒度为1个字节，代码段描述符 

         ;创建以上代码段的别名描述符，安装保护模式下的数据段描述符，该段是32位的段，和上面低段一样
         ;由于代码段是不可写入的（该段低描述符来访问这个区域的时候，处理器不允许其向里面写入数据或者更改数据）
         ;但是很多时候，我们需要对代码段进行一些修改，如中断值令int3
         ;所以当需要修改这个代码段中低数据低时候，就可以使用这个新低描述符来进行操作
         ;alias(别名)两个以上的描述符指向同一个段，
         mov dword [ebx+0x18],0x7c0001ff    ;基地址为0x00007c00，512字节
         mov dword [ebx+0x1c],0x00409200    ;粒度为1个字节，数据段描述符
       
       ;安装堆栈描述符
         mov dword [ebx+0x20],0x7c00fffe  ;基地址是0x7c00,段界限是0xffffe,单位是4KB
         mov dword [ebx+0x24],0x00cf9600
         
         ;初始化描述符表寄存器GDTR，5个描述符，5*8-1=39,
         mov word [cs: pgdt+0x7c00],39      ;描述符表的界限   
 
         lgdt [cs: pgdt+0x7c00];写入到GDTR中
      
         in al,0x92                         ;南桥芯片内的端口 
         or al,0000_0010B
         out 0x92,al                        ;打开A20

         cli                                ;中断机制尚未工作

         mov eax,cr0
         or eax,1
         mov cr0,eax                        ;设置PE位
      
         ;以下进入保护模式... ...,处理器在变更段寄存器以及隐藏的描述符高速缓存器的内容，要检查他代入低合法性

         jmp dword 0x0010:flush             ;16位的描述符选择子：32位偏移
                       ;这之前低代码是16位低，之后低代码是32位的                      
         [bits 32]                          
  flush:                    
       ;对索引号检查，发现超出了表的上界，处理器中断处理，产生异常中断13（一般保护故障，操作系统访问无效内存地址，无效低段选择子，执行特权级别不够的操作或者其他保护错误）
       ;还要对类别进行检查，代码段，则不能加载到除CS以外的段寄存器,type必须是有效值，0000就是一个无效值
       ;还要检查P位，P=0,及时这个描述符是0,但是这个段实际商不在物理内存中（内存空间紧张时候，临时把用的很少低段换出去），此时处理器产生一个中断,把段从硬盘调入内存中
       ;然后设置P位,如果P=1,则设置A位

                   
         mov eax,0x0018                      ;3号数据段，代码段低别名，方便修改代码段的数据
         mov ds,eax
      
         mov eax,0x0008                     ;加载数据段(0..4GB)选择子,1号描述符，数据段
         mov es,eax
         mov fs,eax
         mov gs,eax
      
         mov eax,0x0020                     ;0000 0000 0010 0000；4号描述符，栈段
         mov ss,eax
         xor esp,esp                        ;ESP <- 0
      
         mov dword [es:0x0b8000],0x072e0750 ;字符'P'、'.'及其显示属性
         mov dword [es:0x0b8004],0x072e074d ;字符'M'、'.'及其显示属性
         mov dword [es:0x0b8008],0x07200720 ;两个空白字符及其显示属性
         mov dword [es:0x0b800c],0x076b076f ;字符'o'、'k'及其显示属性

         ;开始冒泡排序 ,我们需要两个循环，一个外循环控制遍历低次数，一个内循环控制比较低次数
         ;所以两个循环都需要使用loop ecx
         ;所以我们就需要使用到对栈
         mov ecx,pgdt-string-1              ;遍历次数=串长度-1 n-1
  @@1:
         push ecx                           ;32位模式下的loop使用ecx ,循环次数压栈,因为内循环会改变ecx低值
         xor bx,bx                          ;32位模式下，偏移量可以是16位，也可以 ，该寄存器在每次内部循环前都清零,用来从字符串的开头进行比较
  @@2:                                      ;是后面的32位 ,32位环境下，也可以使用16位寄存器来进行寻址,操作数是16位+0x66,地址是16位，+0x67
         mov ax,[string+bx]                 ;一次性读取两个字符到ax中,当前数据段是ds指定的，地址是0x00007c00
         cmp ah,al                          ;ah中存放的是源字的高字节 ,
         ;如果前一个字符比后一个字符大，就需要交换两个字符
         jge @@3 
         ;ah<al,说明就需要交换两个字符,然后重新写会到原来低字单元，将bx+1,指向下一个字符
         xchg al,ah ;xchg交换两个操作数，xchg的原操作数和目的操作数必须是相同位大小，寄存器或者内存都可以，但是不可以都是内存
         mov [string+bx],ax ;al和ax修改完之后，写回到原来低字单元
  @@3:
       ;ah>=al
         inc bx 
         loop @@2 
         pop ecx 
         loop @@1

       ;打印修改之后低结果
         mov ecx,pgdt-string
         xor ebx,ebx                        ;偏移地址是32位的情况 
  @@4:                                      ;32位的偏移具有更大的灵活性

         mov ah,0x07
         mov al,[string+ebx]
         mov [es:0xb80a0+ebx*2],ax          ;演示0~4GB寻址。
         inc ebx
         loop @@4
      
         hlt 

;-------------------------------------------------------------------------------
;这个就死我们需要进行排序低字符串
;代码段是用来执行的，能不能读出，取决于描述符的类型，但是都不允许写入
     string           db 's0ke4or92xap3fv8giuzjcy5l1m7hd6bnqtw.'
;-------------------------------------------------------------------------------
     pgdt             dw 0
                      dd 0x00007e00      ;GDT的物理地址
;-------------------------------------------------------------------------------                             
     times 510-($-$$) db 0
                      db 0x55,0xaa