         ;代码清单11-1
         ;文件名：c11_mbr.asm
         ;文件说明：硬盘主引导扇区代码 
         ;创建日期：2011-5-16 19:54

         ;设置堆栈段和栈指针 
         mov ax,cs      
         mov ss,ax       ;使堆栈的段寄存器和代码段相同
         mov sp,0x7c00   ;使栈指针指向0x7c00，之后，栈就从这个点往下增长
         ;从0x7c00开始，代码段向上增长，栈段向下增长

          ;开始定义主引导扇区代码使用的数据段，代码段，堆栈段
          ;保护模式之下，内存的访问模式完全不同，必须通过描述符来进行（一个描述符8个字节）,这些段必须再GDT中定义

          ;开始安装各个描述符,我们现在还处在实模式下，因此，必须将GDT的线性地址转化成为段地址+偏移地址

         ;计算GDT所在的逻辑段地址,将gdt的线性地址的低16位传送到ax中，高16位传送到dx中，现在使用的还是16位寄存器
         ;访问代码段的数据
         mov ax,[cs:gdt_base+0x7c00]        ;低16位 
         mov dx,[cs:gdt_base+0x7c00+0x02]   ;高16位 
          ;将线性地址转化成逻辑地址
         mov bx,16        
         div bx            ;除16后，得到的商是逻辑段地址，余数是偏移地址
         mov ds,ax                          ;令DS指向该段以进行操作,段地址
         mov bx,dx                          ;段内起始偏移地址 ，偏移地址

         ;创建0#描述符，它是空描述符,或者叫哑描述符或 NULL 描述符，这是处理器的要求
         ;处理器切换到保护模式后，GDT被加载，寄存器和内存单元中的初始值都是0,避免引用到任何有效的段描述符
         ;空描述符是一个无效的描述符，这个描述符无法访问任何的内存段
         mov dword [bx+0x00],0x00  ;将两个全0双字写入到bx,bx+4的总共8字节的位置
         mov dword [bx+0x04],0x00  

     ;进入保护模式后，就要从第一个代码段开始执行，现在就来定义代码段的描述符
         ;创建#1描述符，保护模式下的代码段描述符
         ;根据描述符表的描述，这个代码段的段基地址是0x00007c00
         ;粒度G=0,单位是字节
         ;该段长度是0x001ff(511),向上的最大偏移量是511,说明这个段由512个字节,偏移量是从0开始的
         ;S=1,指定这个描述符的类型是代码段或数据段
         ;D=1,这个位是默认操作数大小，D=1说明使用的是32位的段,32位的偏移地址或操作数
         ;P=1,说明这个段目前存在内存中
         ;DPL=00，段的特权级最高
         ;TYPE=1000,说明这个代码段是只执行
         ;这个描述符所指向的段，就是这个正在执行的主引导程序所在的区域
         mov dword [bx+0x08],0x7c0001ff     ;低32位
         mov dword [bx+0x0c],0x00409800     ;高32位

         ;创建#2描述符，保护模式下的数据段描述符（文本模式下的显示缓冲区） 
         ;段地址0x000b8000
         ;G=0，字节单位,段界限0x0ffff,长度是64K
         ;S=1,数据段
         ;D=1,32位段
         ;P=1目前存在内存中
         ;DPL=00,特权是0,最高
         ;TYPE=0010,是一个可读可写的数据段
         mov dword [bx+0x10],0x8000ffff     
         mov dword [bx+0x14],0x0040920b     

         ;创建#3描述符，保护模式下的堆栈段描述符
         ;栈段的基地址0x00000000
         ;段的界限是0x07a00,G=0单位是字节,esp的最小值
         ;S=1数据段
         ;D/B=1,32位,使用的是ESP，B的值也决定了栈的上部边界，B=1，栈段的上部边界是0xffffffff
         ;DPL=0,特权最高
         ;TYPE=0110,这个是一个可读可写，向下扩展的数据段
         mov dword [bx+0x18],0x00007a00
         mov dword [bx+0x1c],0x00409600

          ;现在所有的描述符都已经安装完毕了，接下来就是加载描述符表的线性基地址，界限到GDTR寄存器中

         ;初始化描述符表寄存器GDTR
         ;因为我们处理了4个描述符，所用总共32字节，就是32-1=31的界限值
         mov word [cs: gdt_size+0x7c00],31  ;描述符表的界限（总字节数减一） ,把GDT的界限值写入到gdt_size的地址中  
         ;gdt_size开始的6个字节写入到GDTR中                                     
         lgdt [cs: gdt_size+0x7c00]
      
         in al,0x92                         ;南桥芯片内的端口 ，把数据从0x92中读取出来
         or al,0000_0010B                   ;将第2位设置成1,然后写入端口，这个位就是ALT——A20——GATE，
         out 0x92,al                        ;打开A20
          ;通过打开a20增大寻址空间

         cli                                ;保护模式下中断机制尚未建立，应 
                                            ;禁止中断 
         mov eax,cr0
         or eax,1        ;将CR0的PE位设置1,这个就是打开保护模式的开关
         mov cr0,eax                        ;设置PE位,把数据写回CR0
         ;CR0设置好了之后，现在处理器就处于保护模式了
      
         ;以下进入保护模式... ...
         ;在实模式下，描述符高速缓存器的低20位有效，高12位全0
         ;1.需要尽快刷新段选择器和描述符第高速缓存器，
         ;2.清空流水线
         ;使用远转移，处理器回清空流水线，并串型化执行，远转移会重新加载cs，以及描述符高速缓存器第内容
         ;因为现在是在保护模式下，0x0008不是逻辑段地址了，而是保护模式下第段描述符选择子，
         ;他第选择子cs：0x0008(索引号1,TI=0,RPL=00)，使用的就是代码段的数据
         ;当这个值令执行时，从GDT取出相应第描述符加载到CS描述符高速缓存,使用flush标号第数值来代替eip
         jmp dword 0x0008:flush             ;16位的描述符选择子：32位偏移
                                            ;清流水线并串行化处理器 
         [bits 32] 
         ;应为保护模式下第值令都是32位操作数编译，所以现在就希望使用32位编译

    flush:
     ;保护模式下，ds的低2位是RPL请求特权级，位2是TI表示使用的是LTI还是GDT
     ;后面低几位就是描述符低索引值，由于我们前面注册低数据段是在第3个，所以索引号码就是01
         mov cx,00000000000_10_000B         ;加载数据段选择子(0x10)
         mov ds,cx  ;设置进ds,指定第GDT，rpl=00
         ;将GDTR记录GDT第线性地址+8*索引号=描述符第线性地址，并将这个描述符加载到这个选择器第高速缓冲中，8个字节
         ;此后每当访问内存值令，就不用再梵文GDT的描述符了，直接用当前段寄存器的描述符高速缓存器提供第线性基地址

         ;以下在屏幕上显示"Protect mode OK." 
         mov byte [0x00],'P'  ;直接通过描述符高速缓存器第加载过程
         mov byte [0x02],'r'
         mov byte [0x04],'o'
         mov byte [0x06],'t'
         mov byte [0x08],'e'
         mov byte [0x0a],'c'
         mov byte [0x0c],'t'
         mov byte [0x0e],' '
         mov byte [0x10],'m'
         mov byte [0x12],'o'
         mov byte [0x14],'d'
         mov byte [0x16],'e'
         mov byte [0x18],' '
         mov byte [0x1a],'O'
         mov byte [0x1c],'K'

         ;以下用简单的示例来帮助阐述32位保护模式下的堆栈操作 
         mov cx,00000000000_11_000B         ;加载堆栈段选择子，描述符时3号
         mov ss,cx  ;自动加载到描述符高速缓存区
         ;栈段内偏移第最小值时界限值*粒度+1，在栈中，这个值就是esp的最小值
         mov esp,0x7c00
         
         ;由于是32位，所以压栈第时候，压入双字
         mov ebp,esp                        ;保存堆栈指针 
         push byte '.'                      ;压入立即数（字节）
         
         
         sub ebp,4
         cmp ebp,esp                        ;判断压入立即数时，ESP是否减4 
         
         jnz ghalt                        
         pop eax
         mov [0x1e],al                      ;显示句点 
      
  ghalt:     
         hlt                                ;已经禁止中断，将不会被唤醒 

;-------------------------------------------------------------------------------
          ;GDTR,16位全局描述符表边界，表示这个GDT最多只能有64K的大小，存储8192个fd

          ;在保护模式之下，访问一个段必须先在GDT中定义要访问的内存段（记录段的界限，段的访问属性）
          ;描述符（一个段）不是由用户程序自己创建的，而是在加载的时候，OS创建的，创建好后，用户程序就只能在这个段中工作
     ;gdt_size开始的6个字节，都写入到GDTR中
         gdt_size         dw 0
     ;因为主引导扇区的位置在0x7c00开始的512字节，所以是在0x7e00结束，
         gdt_base         dd 0x00007e00     ;GDT的物理地址 ,先是确定了GDT的起始线性地址，初始化了一个双字32位的物理地址，
                             
         times 510-($-$$) db 0
                          db 0x55,0xaa