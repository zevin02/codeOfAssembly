         ;代码清单8-1
         ;文件名：c08_mbr.asm
         ;文件说明：硬盘主引导扇区代码（加载程序，一个加载器） 
         ;创建日期：2011-5-5 18:17
         
         ;加载器要加载一个用户程序，1；查看内存中的什么地方是空闲的，就是从哪个物理地址开始加载用户程序
         ;2.用户程序在磁盘上的什么位置，逻辑扇区号是多少
            ;equ等于，用标号app_lba_start来表示100,这个就是一个常数，在程序运行期间都保持不变，他不占用内存空间和内存位置，只是一个数
         app_lba_start equ 100           ;声明常数（用户程序起始逻辑扇区号）
                                         ;常数的声明不会占用汇编地址
;这里我们将主引导扇区定义成一个段,vstart=0x7c00，后面的所以汇编地址都是从0x7c00开始计算偏移的，         
SECTION mbr align=16 vstart=0x7c00                                     

         ;设置堆栈段和栈指针 
         mov ax,0      
         mov ss,ax            ;初始化栈段寄存器
         mov sp,ax            ;初始化栈指针寄存器
      
         ;获得一个地址，用户程序从这个地址开始加载
         ;由于数据是32的保存phy_base处的双字单元中，低16位在phy_base中，可以存储在ax中
         mov ax,[cs:phy_base]            ;计算用于加载用户程序的逻辑段地址 
         mov dx,[cs:phy_base+0x02]        ;高16位存储在phy_base+2的位置处，可以存放在dx中，

         ;接着就是该物理地址变成16位的段地址
         mov bx,16        ;由于是16字节对齐，所以直接右移4位（除16）即可
         div bx            
         mov ds,ax                       ;令DS和ES指向该段以进行操作，把段地址存储在ds和es中
         mov es,ax                        
    

      ;前面我们定义了app_lba_start=100,就是用户程序在硬盘上的起始逻辑地址，于从硬盘上读取这个扇区的内容
      ;由于不知道用户程序到底由多大，所以先读取第一个扇区，该扇区
      ;该扇区包含了用户程序的头部（程序的大小，入口，段重定向表）
      ;根据头部就可以知道还要读取多少个扇区才能加载用户程序
      
      ;以下读取程序的起始部分 
      ;我们定义的过程要求使用di:si来保存扇区号，他是一个常数100,所以直接传送到si即可,把di清0


         xor di,di
         mov si,app_lba_start            ;程序在硬盘上的起始逻辑扇区号 
         xor bx,bx                       ;加载到DS:0x0000处 
         ;call调用函数,这个地方使用的是相对近调用，在当前的代码段中，ip+计算的相对偏移量+指令长度
         ;将ip压栈
         call read_hard_disk_0
      
         ;以下判断整个程序有多大
         ;分别将高位存到dx，把低位存到ax中
         mov dx,[2]                      ;曾经把dx写成了ds，花了二十分钟排错 
         mov ax,[0]
         ;每个扇区由512个字节，
         mov bx,512                      ;512字节每扇区
         ;使用bx来进行除法运算,做完除法后，ax中就是结果
         div bx
         
         cmp dx,0
         ;如果dx中不是0,说明有余数，最后一个扇区因为没有填满而被落下

         jnz @1                          ;未除尽，因此结果比实际扇区数少1 
         dec ax                          ;已经读了一个扇区，扇区总数减1 ,如果除干净了，总扇区数就要-1,因为我们已经读了一个扇区的头部了
   @1:
      ;寄存器运行到这的时候，
         cmp ax,0                        ;考虑实际长度小于等于512个字节的情况 
         ;如果ax=0,说明程序已经全部读取完了，不需要再继续读取了，用户程序只占用一个扇区,我们前面已经读取过了
         jz direct                  ;如果ax是0,说明程序刚好等于512字节，或者小于512字节
         
         ;读取剩余的扇区，前面没有跳转说明还有没读取完的扇区
         push ds                         ;以下要用到并改变DS寄存器 
        ;如果是jnz跳转过来的，说明有余数，那么ax中的数就刚刚好就是需要读取的数，不需要-1,因为没有-1,就相等于了+1
        ;ax中保存着要读取多少个扇区
         mov cx,ax                       ;循环次数（剩余扇区数）,设置循环的次数
   @2:
         mov ax,ds
         add ax,0x20                     ;得到下一个以512字节为边界的段地址
         mov ds,ax  
         ;把ds向后面移动512字节，构造一个新的段，因为原来的位置已经被第一个扇区给填充完成了,移动到下一个段地址

        ;ds:si是起始的逻辑扇区号码，ds:bx目标位置


         xor bx,bx                       ;每次读时，偏移地址始终为0x0000 
         inc si                          ;下一个逻辑扇区 ,移动到下一个逻辑扇区

         ;参数传递，主程序把逻辑扇区的高16位存储在di中，低16位存储在si中,并约定把读取出来的数据存放在ds:bx
         ;加载用户程序到内存中
         call read_hard_disk_0
         loop @2                         ;循环读，直到读完整个功能程序 

         pop ds                          ;恢复数据段基址到用户程序头部段 ,指向用户程序被加载的起始地址，就是程序的头部
      
         ;计算入口点代码段基址,重定位程序入口点段代码的汇编地址 
   direct:
         mov dx,[0x08]
         mov ax,[0x06]        ;用户程序的0x06处就是一个双字的段的汇编地址，把低16位存储在ax中，高16位存储在dx中
         call calc_segment_base
         mov [0x06],ax                   ;回填修正后的入口点代码段基址 
      
         ;开始处理段重定位表
         mov cx,[0x0a]                   ;需要重定位的项目数量
         mov bx,0x0c                     ;重定位表首地址
          

          ;用户程序在编写的时候是分段的，加载器接下来需要确定每个段的段地址
 realloc:
         mov dx,[bx+0x02]                ;32位地址的高16位 
         mov ax,[bx]
         call calc_segment_base
         mov [bx],ax                     ;回填段的基址
         add bx,4                        ;下一个重定位项（每项占4个字节） direct
         loop realloc 
      
         jmp far [0x04]                  ;转移到用户程序  
 
;-------------------------------------------------------------------------------

;这个read_hard_disk_0就是我们设计的一个过程,
;过程的第一条指令需要一个标号，方便我们引用该过程函数
;这里我们传送的是100
read_hard_disk_0:                        ;从硬盘读取一个逻辑扇区
                                         ;输入：DI:SI=起始逻辑扇区号
                                         ;      DS:BX=目标缓冲区地址
      ;为了保持连续性质，把本过程要使用的寄存器临时压栈（在调用函数之前，这些寄存器可能都存储着有效的数据）,在函数调用完之后，在把这些数据出栈回复
         push ax
         push bx
         push cx
         push dx
      
      ;向0x1f2写入要读取的扇区数
         mov dx,0x1f2               
         mov al,1                   ;只希望读取一个扇区
         out dx,al                       ;读取的扇区数
      ;写入起始的LBA扇区号,低16位在si中,
         inc dx                          ;0x1f3
         mov ax,si                        ;把低16位放到ax中
         out dx,al                       ;LBA地址7~0，先放进去低8位，在al中,写入

         inc dx                          ;0x1f4
         mov al,ah
         out dx,al                       ;LBA地址15~8,ah写入到al中，再把al写入到dx中

         inc dx                          ;0x1f5
         mov ax,di                        ;高16位在di中，写入到ax中
         out dx,al                       ;LBA地址23~16

         inc dx                          ;0x1f6
         mov al,0xe0                     ;LBA28模式，主盘
         or al,ah                        ;LBA地址27~24
         out dx,al

         inc dx                          ;0x1f7
         mov al,0x20                     ;读命令,0x20就是一个读命令
         out dx,al
      
      ;4.等待读写操作完成，0x1f7既是一个命令端口也是一个状态端口，给这个命令发送读写命令之后，硬盘就开始工作了
      ;0x1f7端口的第7个位置，如果是1表示自己忙，如果硬盘系统准备完成了，这个标志位就被清0了，
      ;如果第3位被设置成1,就表示准备号了，请求主机发送或者接收数据

  .waits:
         ;现在的dx就是0x1f7

         in al,dx       ;从dx的0x1f7中读取数据到al中
         and al,0x88    ;保留住al寄存器的第3和7位，获得这两个标志位，检查硬盘是否忙，硬盘是否已经准备好了
         cmp al,0x08
         ;如果al寄存器的状态是0x08的话，就结束等待状态，否则说明这个硬盘还是忙，同时还没有准备号
         jnz .waits                      ;不忙，且硬盘已准备好数据传输 
      
      ;5.连续取出数据,0x1f0是硬盘的数据端口，还是一个16位端口,一旦硬盘控制器空闲，准备就绪，就可以连续从这个端口写入或者读取数据
      ;从磁盘中读取一个扇区
         mov cx,256                      ;总共要循环的次数，每次读取1个字，循环256次，就可以读取512字节，一个扇区的大小
         mov dx,0x1f0               ;读取的数据存放在ds中
         
  .readw:
         in ax,dx       ;由于0x1f0是一个16位的端口，一次可以读取2个字节的数据,现在就是把dx中的数据读取到ax中q
         mov [bx],ax    ;把读取到的数据存放在ds：bx中
         add bx,2       ;bx往后偏移
         ;由于我们设置了cx为256,所以这里要循环256次来读取512个字节
         loop .readw

      ;用于从栈中恢复之前压栈的寄存器数据
         pop dx
         pop cx
         pop bx
         pop ax
      
            ;ret和call是配对使用的，是近返回，处理器做的就是把栈中的ip数据出栈
            ;同时还有一个retf指令，是远程返回，搭配call far,指令的时候把cs和ip都出栈
         ret      ;过程调用完之后，使用ret来离开这个函数调用

;-------------------------------------------------------------------------------
;接收一个32位的汇编地址，dx:ax，并把计算后向主程序返回一个16位的段地址
calc_segment_base:                       ;计算16位段地址
                                         ;输入：DX:AX=32位物理地址
                                         ;返回：AX=16位段基地址 
      
         push dx                          ;由于计算的过程中需要破坏dx的值，所以需要将dx进行一个压栈
         ;dx:ax之前是记录这个程序的段的起始的段地址（汇编地址）
         ;add加完之后，计算出来相应的实际的物理地址，程序的入口的实际物理地址
         add ax,[cs:phy_base]             ;先将用户程序在内存中的物理起始地址的低16位先加到ax中
         ;add计算完之后，会对cf产生影响可能会有进位
         adc dx,[cs:phy_base+0x02]
         ;现在dx:ax中就是内存中该程序的实际物理位置
         ;现在我们需要将这个32位数右移4位就可以得到逻辑段地址
         ;shr把左边空出来的bit用0来填充，右边被推走的被放入cf中
         shr ax,4
         ror dx,4 ;使用循环右移，4位，移动的即写到dx的左边，右写到cf标志位中
         
         and dx,0xf000;我们只需要高4位，剩下的12位我们都不需要，直接清除掉
         or ax,dx ;或上之后，实际物理内存中的程序的起始段地址就在ax中了
         
         pop dx               ;
         
         ret;返回到程序掉用的地方

;-------------------------------------------------------------------------------
         ;加载用户程序需要一个确定的内存物理地址，用一个32位的单元来容纳一个20位的地址
         ;这个物理地址可以是任何地方，只要这个物理地址是空闲的即可,但是必须是16字节对其的
         phy_base dd 0x10000             ;用户程序被加载的物理起始地址
         
 times 510-($-$$) db 0
                  db 0x55,0xaa